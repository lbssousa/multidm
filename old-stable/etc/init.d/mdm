#!/bin/bash

# Copyright (C) 2004-2007 Centro de Computacao Cientifica e Software Livre
# Departamento de Informatica - Universidade Federal do Parana - C3SL/UFPR
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
# USA.

# This script is responsible for discovering how many seats we have and then
# call X and Xephyr for all of them.
#
# This script needs to be called after create_xorg_conf and gdm
#
# This script has 3 options: start, stop and restart

SBIN_INSTALL_DIR=/usr/sbin
#SHARE_INSTALL_DIR=/usr/share/mdm/      not used here...
ETC_INSTALL_DIR=/etc/mdm/
LOG_DIR=/var/log/mdm                    # log directory
DEBUG_LOG=$LOG_DIR/mdm_debug.log        # debug log file

DISCOVER_HEADS=$SBIN_INSTALL_DIR/discover_heads.sh
CONFIGURE_HEAD=$SBIN_INSTALL_DIR/configure_head.sh
LINKS_PATH=/dev/input
X=/usr/bin/X
LOCKS=$LINKS_PATH
MDM_XORG_CONF=/etc/X11/xorg.conf.mdm
MDM_CONF=$ETC_INSTALL_DIR/mdm.conf
PIDS=/var/run/mdm
XAUTH_FILE=$LOG_DIR/Xauth

source $MDM_CONF

#
# WRITE_DEBUG
#
# check if DEBUG_MULTISEAT is defined and is equals to 1. I    n this case,
# write a message in a debug file.
#
# Parameters: $1 = Text 1 to write
#             $2 = Text 2 to write
#
# Returns: nothing
 
function write_debug()
{
    if [[ $DEBUG_MULTISEAT -eq 1 ]]; then
        touch $DEBUG_LOG
        # write debug text to file
        echo -e "`date "+%D %R"` $1 $2" >> $DEBUG_LOG 
    fi
} # write_debug

function exec_start () {

    write_debug "Starting exec_start()"
    # Discover how many seats we have
    N_MICE=$($DISCOVER_HEADS mouse | wc -l)
    N_KEYBOARDS=$($DISCOVER_HEADS kbd | wc -l)
    N_CARDS=$($DISCOVER_HEADS bus | wc -l)

    HEADS=$N_CARDS                  # PRD
#    HEADS=$N_MICE
#    for i in $N_KEYBOARDS $N_CARDS; do
#        if [[ i < HEADS ]]; then
#           HEADS=$i
#        fi
#    done

    echo "`basename $0`: $N_MICE mice detected"
    echo "`basename $0`: $N_KEYBOARDS keyboards detected"
    echo "`basename $0`: $N_CARDS video cards detected"
    echo "`basename $0`: $HEADS heads detected"

    write_debug "$N_MICE mice detected"
    write_debug "$N_KEYBOARDS keyboard(s) detected"
    write_debug "$N_CARDS card(s) detected"
    write_debug "$HEADS head(s) detected"

    # Maybe we still have a lock file from the last time we executed?
    for i in `ls $LOCKS | grep "^mdm"`; do
        rm -f $LOCKS/$i
    done
    
    # Remove old PIDs files 
    for i in `ls $PIDS`; do
	    rm -f $PIDS/$i
    done

    if [[ $HEADS == 1 ]]; then
        case $DISPLAY_MANAGER in
            gdm)
                gdmdynamic "-a 0=StandardHandled"
                gdmdynamic "-r 0"
                ;;
            remote)
                write_debug "Remote. Single Head. Query Command: $QUERY_COMMAND"
                $X -dpi 92 -query $QUERY_COMMAND -config $MDM_XORG_CONF 2> $LOG_DIR/X.log &
                PID=$!
                echo $PID > $PIDS/X.pid
                wait $PID
                rm -f $PIDS/X.pid                
                ;;
            *)
                echo "Error parsing the config file! Invalid DISPLAY_MANAGER."
                ;;
        esac
    else
        # Load an X server that is not handled by the display manager
        # XXX: make it possible to use other DMs!
        case $DISPLAY_MANAGER in
            gdm)
                gdmdynamic "-a 0=StandardNotHandled"
                gdmdynamic "-r 0"
                # We have to wait the XXX server finish loading...
                sleep 4
                for (( i=0 ; i < $HEADS ; i++ )); do
                    export DISPLAY=:0.$i
                    $CONFIGURE_HEAD $((i+1)) &
                    PID=$!
                    echo $PID > $PIDS/configure_head_$i.pid
                done
                ;;
            remote)
                write_debug "REMOTE Conection started..."
                $X -br -noreset -dpi 92 -config $MDM_XORG_CONF 2> $LOG_DIR/X.log &
                PID=$!
                echo $PID > $PIDS/X.pid
                # X is loading... wait to complete
                sleep 6
                write_debug "Generating XAUTH file"
                xauth -f ${XAUTH_FILE} generate :0
                
                for (( i=0 ; i < $HEADS ; i++ )); do
                    write_debug "Calling CONFIGURE_HEAD. Head $i+1"
                    export DISPLAY=:0.$i
                    $CONFIGURE_HEAD $((i+1)) &
                    PID=$!
                    echo $PID > $PIDS/configure_head_$i.pid
                done
                write_debug "Exiting remote call"
                ;;
            *)
                echo "Error parsing the config file! Invalid DISPLAY_MANAGER."
                ;;
        esac
    fi
    write_debug "Exiting exec_start()"
} # exec_start

function exec_stop() {

    write_debug "Starting exec_stop()"
    # XXX If the user changes the DISPLAY_MANAGER variable inside mdm.conf,
    # we might have problems executing the stop...
    case $DISPLAY_MANAGER in
        gdm)
            # Close gdm...
            DISPLAYS_USED=`gdmdynamic -l -s 1 -t 1 | sed 's/:/\n/g' | cut -d',' -f1`
            write_debug "exec_stop: DISPLAY_USED=$DISPLAYUSED"
            for i in $DISPLAYS_USED; do
                write_debug "gdmdynamic -d $i -s 1 -t 1"
                gdmdynamic "-d $i -s 1 -t 1"
            done
            ;;
        remote)
            write_debug "REMOTE Conection stoped!"
	        ;;
        *)
        ;;
    esac

    for i in `ls $PIDS`; do
        kill `cat $PIDS/$i` 2> /var/log/mdm/kill.log
	rm -f $PIDS/$i
    done
    for i in `ls $LOCKS | grep "^mdm"`; do
        rm -f $LOCKS/$i
    done
    write_debug "Exiting exec_stop()"
} # exec_stop

# ******************** MAIN *************************
#
# Parameters:
#
#   start       init mdm module
#   stop        finish mdm module
#   restart     stop/start
#   reconfigure remove links to keyboard/mouse and start mdm module
#   moo         panic!!! Kill mdm modules
#

if [[ -z $DEBUG_MULTISEAT ]]; then
    DEBUG_MULTISEAT=0                       # no debug function
fi
write_debug "mdm init module starting"
if  [[ "$#" -lt 1 ]]; then
    echo "Usage: `basename $0 ` {start|stop|restart}" 
    # |force-config}
    write_debug "Invalid parameters: $?"
    exit 1
fi
# Create PIDs directory
if [[ ! -d $PIDS ]]; then
    mkdir -p $PIDS
fi
# Create LOGs directory
if [[ ! -d $LOG_DIR ]]; then
    mkdir -p $LOG_DIR
fi
# Parse parameters
case $1 in

    start)
        exec_start	
	    ;;
    stop)
        exec_stop
	    ;;
    restart)
        exec_stop
        exec_start
	    ;;

    reconfigure)
        LINKS=`ls $LINKS_PATH | grep "^mdm"`
    	for i in $LINKS; do
            rm -f $LINKS_PATH/$i
        done
        exec_start
        ;;
    kill)
        if [[ ! -z $2 ]]; then
            kill `cat $PIDS/configure_head_$(( $2 - 1 )).pid` `cat $PIDS/Xephyr:0.$(( $2 - 1 )).pid`
            rm -f /dev/input/mdm{Kbd,Mouse}$2
	        export DISPLAY=:0.$(( $2 - 1 ))
            $CONFIGURE_HEAD $2 &
            PID=$!
            echo $PID > $PIDS/configure_head_$(( $2 - 1 )).pid
        fi
        ;;
    moo)
        write_debug "Option MOO called."
        exec_stop
        pkill gdm
        pkill Xephyr
        write_debug "Xephyr pkilled? `ps -ax | grep Xephyr`"
        pkill X
        write_debug "X pkilled? `ps -ax | grep X`"
        pkill read_devices
        write_debug "read_devices pkilled? `ps -ax | grep read_devices`"
        pkill configure_head.sh
        write_debug "configure_head.sh pkilled? `ps -ax | grep configure_head`"
        echo "MoooOOooOOOOoOoOoo..."
        write_debug "All done?? Exiting moo."
        ;;
    *)
        write_debug "Invalid parameter: $1"
        echo "Usage: `basename $0 ` {start|stop|restart|reconfigure}"
        ;;
esac

exit 0
